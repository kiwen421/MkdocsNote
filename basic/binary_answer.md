本页面将介绍二分答案的使用。



### 定义

二分答案一般用来求极值， 例如： 满足某种条件的最大值/最小值 ， 其本质还是进行枚举，与枚举不同的是通过二分法把枚举的数量优化了。



### 过程

例如： 求满足某种条件的最小值。

1.  假设 $x$ 是满足条件的最大值， 那么$[0, x]$ 区间内还可能存在最小的解，那么设置`L=0 R=x` 进行二分
2.  判断 `mid` 是否满足条件 ，如果满足条件，更新最小值，接着向左探测； 否则退出



### 代码模版

```cpp
bool check(int x){
  
  // 判断x是否符合条件
}
// 判断满足某种条件的最小值
int binary_answer(int L, int R){
  int ret = -1;
  int mid;
  while (L <= R){
    mid = L + (R-L)>>1;
    if (check(mid)){   // 判断是否满足条件
      ret = mid;     // 更新最小值
      R = mid - 1;
    } else L = mid + 1;
  }  
  return ret;
}
```



???+ note  "[Luogu P1873 砍树](https://www.luogu.com.cn/problem/P1873)"
    伐木工人米尔科需要砍倒 $M$ 米长的木材。这是一个对米尔科来说很容易的工作，因为他有一个漂亮的新伐木机，可以像野火一样砍倒森林。不过，米尔科只被允许砍倒单行树木。
    

    米尔科的伐木机工作过程如下：米尔科设置一个高度参数 $H$（米），伐木机升起一个巨大的锯片到高度 $H$，并锯掉所有的树比 $H$ 高的部分（当然，树木不高于 $H$ 米的部分保持不变）。米尔科就得到树木被锯下的部分。
    
    例如，如果一行树的高度分别为 $20,~15,~10,~17$，米尔科把锯片升到 $15$ 米的高度，切割后树木剩下的高度将是 $15,~15,~10,~15$，而米尔科将从第 $1$ 棵树得到 $5$ 米木材，从第 $4$ 棵树得到 $2$ 米木材，共 $7$ 米木材。
    
    米尔科非常关注生态保护，所以他不会砍掉过多的木材。这正是他尽可能高地设定伐木机锯片的原因。你的任务是帮助米尔科找到伐木机锯片的最大的整数高度 $H$，使得他能得到木材至少为 $M$ 米。即，如果再升高 $1$ 米锯片，则他将得不到 $M$ 米木材。

??? note "解题思路"
    通过题意可知，伐木机可能的最大高度为其中最高树木的高度,设为x，我们可以在 $0$ 到 $x$ 中枚举答案，但是这种朴素写法肯定拿不到满分，因为从 $0$ 枚举到 $x$ 太耗时间。我们可以在 $[0, x]$ 的区间上进行二分作为答案，然后检查各个答案的可行性（一般使用贪心法）。**这就是二分答案。**

???+ note highlight "参考代码"
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e6 + 10;
    int f[N];
    int n, m,  _max=0;
    
    bool check(int k) {  // 检查可行性，k 为锯片高度
    	long long sum = 0;
    	for (int i = 1; i <= n; i++){
          if (f[i] > k)  sum += (long long)(f[i] - k);     // 累加树木高度
    	}
    	return sum >= m;               
    }
    
    int binary_answer(int L, int R){
        int ret = -1;
        int mid;
        while (L <= R) {       
            mid = L + (R-L) >> 1;  
            if (check(mid)) {    // 判断可行性
                ret = mid;
                L = mid + 1;
            } else R = mid - 1;
        }
        return ret;  
    }
    
    int main(){
        cin >> n >> m;
        for (int i = 1; i <= n; i++) {
            cin >> f[i];
            _max = max(f[i], _max); // 可行性答案的最大高度
        }
        cout << binary_answer(0, _max);
        return 0;
    }
    ```
